# 2 어휘구조

## 1 텍스트
+ 대소문자 구분 → 대소문자를 일관적으로 써야 함
+ 스페이스, 줄바꿈 무시 → 마음대로 쓸 수 있어, 읽고 이해하기 쉽게 일관적인 형식으로 쓸 수 있음
+ 스페이스 문자, 탭, ASCII 제어 문자, 유니코드 스페이스 문자를 공백으로 인식
+ 뉴라인, 캐리지 리턴(`\r`), 라인 피드(`\n`)를 줄바꿈 문자로 인식 

## 2 주석
```js
// 한 줄 주석

/*
여러 줄 주석
*/
```

## 3 리터럴
리터럴: 프로그램 안에 직접 쓴 데이터의 값

3장에서 자세히... (숫자와 문자열 리터럴)

## 4 식별자와 예약어
식별자: 상수, 변수, 프로퍼티, 함수, 클래스의 이름을 비롯한 일부 루프 라벨로 사용

+ 글자(알파벳), 밑줄(`_`), 달러기호(`$`)로 시작해야 함
+ 💥 숫자로 시작하지 않음! 식별자와 숫자를 구별하기 위함
<br/>
예약어: 식별자로 사용 피하기

+ `if`, `while`, `for` 등: 예약된 키워드로 상수, 변수, 함수, 클래스 이름으로 사용 불가(객체 프로퍼티는 사용 가능)
+ `let`: 클래스 외부에서 `var`로 선언 가능, 클래스 내부에서나 `const`로 선언해서 사용 불가능
+ 위 단어를 비롯해서 제한된 키워드 다수. __그냥 쓸 수 없다고 생각하자.__

## 5 유니코드
식별자로 일반적으로 ascii문자와 숫자를 쓰지만, 유니코드, 글자, 숫자, 상형문자 모두 허용함.
<br/>
+ 유니코드 정규화: ascii문자가 아닌 문자를 사용할 때, __인코딩 방법이 하나 이상 있음을 알고 있어야 함.__
```js
const name1 = '\u00e9';
const name2 = '\u0301';

console.log(`${name1}, ${name2}`); // => "é, é" 텍스트로는 같아보이지만

console.log(name1 === name2);      // => false 자바스크립트는 다르게 인식함

const name1NFC = name1.normalize(NFC);     // 정규화 메서드 "str.normalize([form])"로,
const name2NFC = name2.normalize(NFC);     // 문자열을 유니코드 정규화 방식(NFC, NFD, NFKC, NFKD)에 따라 정규화된 형태로 반환

console.log(name1NFC === name2NFC);     // => true
```
<br/>

+ escape sequence: `\u` + 4개의 16진수 혹은 `\u` + `{` 1~6개의 16진수 `}` <br/> ES6에서 이모지처럼 16비트 이상의 유니코드 포인트를 지원하기 위해 중괄호 문법을 도입함.

## 6 선택사항인 세미콜론
두 문 사이에 줄바꿈이 있으면 세미콜론을 생략해도 되나, 종종 의도치 않은 결과를 부를 수 있으므로 나는 명시하는 게 좋다고 생각한다.
```js
let a = x + f
(a+b).toString() // let a = x + f(a+b).toString(); 이렇게 해석됨

return 
true.            // return; true; 이렇게 해석됨
```

